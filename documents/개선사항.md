# 문제점 파악.

1. 현재 PUBLIC 단일 스키마만 조회되는 이슈가 있어. 전체 스키마를 가져오되, VIEW 테이블만 존재하는 스키마도 불러와야한다는게 목적이야.

2. '스키마 필터' 기능을 확장하고 싶어.
명확하게 분류하는게 아니라, like 검색으로해서 public이라고 하면 pulbic, public_staging, public_intermediate 등등 스키마만 필터할 수 있도록 해야해.


---------------
## 기능 개선 희망 사항(불가능하거나 프로그램 활용성에 맞지 않는 경우에는 제외 > 제외사유 작성 요망)

스키마 조회 후, 소스 테이블과 타겟 테이블을 선택하는 로직이 있는데 여기서 불러온 테이블들에 대해서 소스와 타겟용으로 테이블을 선택하기 쉽게 구분해서 알려주고 싶어.

예) 
- 소스 테이블 리스트 오픈
public.ods_tablename (소스 테이블 추천)
public.stg_tablename (소스 테이블 추천)
public.dw_tablename (소스 테이블 추천)
public.dm_tablename
public.fact_tablename
public.dim_tablename
public.f_tablename
public.d_tablename
public.ods_tablename2 (소스 테이블 추천)

- 타겟 테이블 리스트 오픈
public.ods_tablename
public.stg_tablename
public.dw_tablename
public.dm_tablename (타겟 테이블 추천)
public.fact_tablename (타겟 테이블 추천)
public.f_tablename (타겟 테이블 추천)
public.dim_tablename (타겟 테이블 추천)
public.d_tablename (타겟 테이블 추천)
public.ods_tablename2

---------------
## 기능 개선(위 내용) 사항에 대한 작업 제안

1. “자동 제안 + 사람 확정 + 메타 저장” 구조로 개선

2. 아키텍쳐 로드맵
[DB Scan]
    ↓
[Auto Scoring Engine]
    ↓
[Suggestion Result]
    ↓
[Human Confirmation UI]
    ↓
[Metadata Persist Layer]
    ↓
[Agent Consumption Layer]

3. 작업 제안 내용
- Implement a hybrid classification system for database tables:
    - Auto-suggestion using scoring rules (naming + structure)
    - Human confirmation via UI
    - Persist both suggested and confirmed roles in metadata.table_role
    - Agent must consume only confirmed metadata
    - Support incremental detection of new tables

---------------
## 구현 완료 내역 (2026-02-28)

### 1. LIKE 패턴 스키마 매칭 — `db_schema.py`
- **변경**: `PostgreSQLSchemaFetcher.__init__()` / `connect()`
- 단일 값 `"public"` → `LIKE 'public%'` 자동 적용 (public, public_staging 등 매칭)
- 콤마 구분 `"public,marts"` → 각각 exact match
- `%`, `*` 와일드카드 명시 지원
- VIEW 전용 스키마도 `include_views: true`와 함께 자동 포함

### 2. 테이블 역할 분류 엔진 — `aetl_metadata_engine.py`
- **meta_tables** 컬럼 추가: `suggested_role`, `confirmed_role`, `role_updated_at`
- `classify_table_role()`: 네이밍 패턴 기반 자동 분류
  - SOURCE: `ods_`, `stg_`, `dw_`, `raw_`, `src_`, `ext_`, `load_`
  - TARGET: `dm_`, `fact_`, `dim_`, `f_`, `d_`, `rpt_`, `agg_`, `mart_`
  - 스키마 힌트: source 계열 / target 계열
- `sync_schema()`: 동기화 시 `suggested_role` 자동 채움
- 새 API: `get_tables_with_roles()`, `confirm_table_role()`, `clear_table_role()`, `get_role_summary()`

### 3. UI 추천 라벨 — `etl_streamlit_app.py`
- 소스/타겟 selectbox에 `"(소스 추천)"` / `"(타겟 추천)"` 라벨 표시
- 추천 테이블 리스트 상단 정렬
- 테이블 역할 관리 expander: 역할 확정 UI

### 4. Agent 도구 — `aetl_agent.py`
- `get_tables_by_role` 도구 추가 (source/target/all 필터링)
- 시스템 프롬프트 업데이트

---------------
## 문제점 발견 (2026.03.01)

1. DB연결 후 테이블 스키마 조회 시, 테이블 및 컬럼 확인 가능하지만 컬럼의 '데이터 타입 | PK | NULL'과 같은 제약조건은 확인 불가.

2. 조회 쿼리 자체에 문제가 있는지 확인이 필요함.

3. 참고할만한 피드백 내용

- PostgreSQL
SELECT
    a.attname AS column_name,
    pg_catalog.format_type(a.atttypid, a.atttypmod) AS data_type,
    NOT a.attnotnull AS nullable,
    con.contype AS constraint_type,
    con.conname AS constraint_name
FROM pg_attribute a
JOIN pg_class c ON a.attrelid = c.oid
JOIN pg_namespace n ON c.relnamespace = n.oid
LEFT JOIN pg_constraint con
       ON con.conrelid = c.oid
       AND a.attnum = ANY(con.conkey)
WHERE n.nspname = %s
  AND c.relname = %s
  AND a.attnum > 0
  AND NOT a.attisdropped
ORDER BY a.attnum;

- MariaDB
SELECT
    c.COLUMN_NAME,
    c.COLUMN_TYPE,
    c.IS_NULLABLE,
    tc.CONSTRAINT_TYPE,
    tc.CONSTRAINT_NAME
FROM information_schema.COLUMNS c
LEFT JOIN information_schema.KEY_COLUMN_USAGE kcu
       ON c.TABLE_SCHEMA = kcu.TABLE_SCHEMA
      AND c.TABLE_NAME = kcu.TABLE_NAME
      AND c.COLUMN_NAME = kcu.COLUMN_NAME
LEFT JOIN information_schema.TABLE_CONSTRAINTS tc
       ON kcu.CONSTRAINT_NAME = tc.CONSTRAINT_NAME
      AND kcu.TABLE_SCHEMA = tc.TABLE_SCHEMA
      AND kcu.TABLE_NAME = tc.TABLE_NAME
WHERE c.TABLE_SCHEMA = %s
  AND c.TABLE_NAME = %s
ORDER BY c.ORDINAL_POSITION;

- Oracle
SELECT
    col.COLUMN_NAME,
    col.DATA_TYPE,
    col.NULLABLE,
    cons.CONSTRAINT_TYPE,
    cons.CONSTRAINT_NAME
FROM ALL_TAB_COLUMNS col
LEFT JOIN ALL_CONS_COLUMNS cons_col
       ON col.OWNER = cons_col.OWNER
      AND col.TABLE_NAME = cons_col.TABLE_NAME
      AND col.COLUMN_NAME = cons_col.COLUMN_NAME
LEFT JOIN ALL_CONSTRAINTS cons
       ON cons_col.CONSTRAINT_NAME = cons.CONSTRAINT_NAME
      AND cons_col.OWNER = cons.OWNER
WHERE col.OWNER = :owner
  AND col.TABLE_NAME = :table_name
ORDER BY col.COLUMN_ID;